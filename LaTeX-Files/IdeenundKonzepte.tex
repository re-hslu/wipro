\section{Konzept zur Übernahme der iOS-Applikation auf Android}

Die Android-Applikation soll auf Basis von Jetpack Compose funktional auf
denselben Stand gebracht werden wie die aktuelle Dev-Version der
iOS-Applikation. Die iOS-App dient dabei aus unserer Sicht als vollständige
Referenz, sowohl in Bezug auf den Funktionsumfang als auch auf den
grundsätzlichen Aufbau der Applikation. Ziel ist es, dass beide Plattformen
möglichst ähnlich strukturiert sind, um zukünftige Arbeiten zu vereinfachen
und den Einstieg für neue Entwicklerinnen und Entwickler zu erleichtern.

Eine vollständige 1:1-Übernahme ist dabei nicht in allen Bereichen möglich,
da sich iOS und Android sowie die Programmiersprachen Swift und Kotlin in
einigen Aspekten unterscheiden. Dennoch sollen das grundlegende Vorgehen,
die Projektstruktur sowie die Benennung von Modulen und Komponenten so weit
wie möglich angeglichen werden. Wie bereits bei der iOS-Applikation soll
auch die Android-App klar in \texttt{Common}-Komponenten und einzelne
\texttt{Feature}-Module unterteilt werden, damit fachlich unabhängige Logik
zentral wiederverwendet werden kann.

\vspace{0.5em}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.43\textwidth]{Fotos/ios-projektstruktur.png}
    \caption{iOS-Projektstruktur in XCode}
    \label{fig:iosprojektstrukur}
\end{figure}

\section{Technologien und Architekturkonzept}

Ein weiteres Ziel ist es, moderne Android-Technologien einzusetzen und
veraltete Komponenten zu ersetzen. Dabei soll aber  nicht alles Bestehende pauschal ersetzt werden. 
Android-Frameworks und Komponenten, die in früheren Hochschul-Apps bereits eingesetzt 
wurden und weiterhin aktuell sowie empfohlen sind, sollen nach Möglichkeit 
weiterverwendet werden. Wo sinnvoll, werden diese Komponenten auf den neuesten 
Stand gebracht und aktualisiert, anstatt sie komplett neu zu implementieren.

Im Rahmen des Projekts kommen deshalb unter anderem folgende
Android-Technologien zum Einsatz:
\begin{itemize}
    \item \textbf{Jetpack Compose}: Deklaratives UI-Framework für moderne Benutzeroberflächen \parencite{google_jetpack_nodate}.
    \item \textbf{Kotlin Coroutines \& Flow}: Vereinfachte asynchrone
    Verarbeitung und reaktiver Umgang mit Datenströmen \parencite{google_kotlin-ablaufe_nodate}.
    \item \textbf{Room Persistence}: Strukturierte und typsichere lokale
    Datenhaltung \parencite{google_persist_nodate}.
    \item \textbf{Hilt (Dependency Injection)}: Klare Verwaltung von
    Abhängigkeiten und bessere Testbarkeit \parencite{google_dependency_nodate}.
\end{itemize}\newpage

Auch auf Architekturebene soll ein sauberer Aufbau verfolgt
werden, der sich auch teilweise an der bestehenden iOS-Lösung orientiert. Dazu
werden bekannte Architektur- und Design-Patterns eingesetzt, um die App
übersichtlich und erweiterbar zu halten. Dazu zählen unter anderem:
\begin{itemize}
    \item \textbf{Clean Architecture}: Klare Trennung von fachlicher Logik,
    Infrastruktur und Darstellung \parencite{martin_clean_2018}.
    \item \textbf{Repository Pattern}: Einheitlicher Zugriff auf Netzwerk-
    und lokale Datenquellen \parencite{evans_domain-driven_2003}.
    \item \textbf{Feature-basierte Modulstruktur}: Jedes Feature ist als
    eigenes Modul umgesetzt, gemeinsame Logik liegt in zentralen
    Common-Modulen.
    \item \textbf{Template- und Strategy-Pattern}: Flexible und
    wiederverwendbare Module-Loader für unterschiedliche
    Datenlade-Strategien \parencite{gamma_design_1995}.
\end{itemize}

Zusätzlich wird bei der Umsetzung der Benutzeroberfläche auf moderne
UI-Patterns gesetzt, die gut mit Jetpack Compose zusammenspielen. Ziel ist eine reaktive,
wiederverwendbare und gut wartbare UI, die sich flexibel an unterschiedliche
Features anpassen lässt.

Konkret kommen dabei unter anderem folgende UI-Konzepte zum Einsatz:
\begin{itemize}
    \item \textbf{Material Design 3}: Verwendung moderner Material-Komponenten
    mit einheitlichem Theming über die gesamte App \parencite{google_material_nodate}.
    \item \textbf{Reaktives UI-Management}: Einsatz von \texttt{StateFlow} in
    Kombination mit \texttt{collectAsState()}, um UI-Zustände reaktiv und
    nachvollziehbar abzubilden. \texttt{LaunchedEffect} wird für Side-Effects
    in Compose verwendet.
    \item \textbf{Component-Based UI}: Wiederverwendbare Composables werden im
    \texttt{Common/Presentation}-Modul abgelegt. Styling erfolgt über das
    Modifier-Pattern, Interaktionen über Lambda-Callbacks, um eine flexible
    Nutzung in verschiedenen Features zu ermöglichen.
\end{itemize}


Abschliessend soll die Android-Applikation über einen automatisierten
Build- und Release-Prozess produktiv im Google Play Store veröffentlicht
werden. Dafür wird Fastlane eingesetzt, um Releases reproduzierbar und
zuverlässig auszuliefern \parencite{fastlane_fastlane_nodate}.
\vspace{-0.2em}
\section{Multi-Tenant- und Backend-Konzept}
\vspace{-0.6em}
Die bestehende App-Landschaft der Hochschule Luzern basiert bereits auf einem
Multi-Tenant-Ansatz, welcher im Rahmen dieses Projekts weiterverfolgt wird.
Ziel ist es, mit einer gemeinsamen Codebasis mehrere Applikationen für
unterschiedliche Departemente zu betreiben. Aktuell betrifft dies die
Departemente Informatik (I) sowie Technik \& Architektur (TA). Aus derselben
Codebasis können dadurch mehrere App-Varianten erzeugt werden, die sich
in deren Inhalten unterscheiden.

Die Inhalte der Applikation werden nicht fest in der App hinterlegt, sondern
zur Laufzeit aus einem zentralen Backend geladen. Dazu gehören unter anderem
Menüstruktur, Inhalte oder Texte. Dieser Ansatz ermöglicht es,
Inhalte anzupassen oder zu erweitern, ohne dass dafür ein neues App-Update im
App Store oder Play Store veröffentlicht werden muss.
\vspace{-0.2em}
\section{Konzept für Testing und Qualität}
\vspace{-0.6em}
Die Qualität der Applikation soll  durch den Einsatz von automatisierten
Tests sichergestellt werden. In den bisherigen iOS- und Android-Projekten wurde
das Thema Testing etwas vernachlässigt, was im Rahmen dieses Projekts
verbessert werden soll.

Geplant ist der Einsatz von Unit- sowie einfachen Integrations- und UI-Tests,
um zentrale Funktionen der App abzusichern. Dafür werden unter anderem
Frameworks wie JUnit und Espresso eingesetzt \parencite{google_test_nodate}. Die konkrete Umsetzung und
Erfahrungen damit werden im Kapitel zur technischen Validierung beschrieben
(siehe Abschnitt~\ref{sec:validieung}).

\section{Geplantes Vorgehen zum AI-First-Ansatz}

Für den geplanten AI-First-Ansatz soll künstliche Intelligenz bewusst und aktiv in den
Entwicklungsprozess eingebunden werden. Ziel ist es nicht, die Entwicklung
vollständig zu automatisieren, sondern AI als unterstützendes Werkzeug im
Arbeitsalltag der Entwickler zu nutzen.

AI soll insbesondere dort eingesetzt werden, wo sie einen praktischen
Mehrwert bietet. Dazu wird zu Beginn des Projekts eine erste
Evaluationsphase durchgeführt (siehe Abschnitt~\ref{sec:ai-eval}). In dieser
Phase wird geprüft, welche AI-Tools sich sinnvoll in den
Entwicklungsprozess integrieren lassen und welche davon tatsächlich eine
Unterstützung im Alltag bieten.

AI-Tools, die sich in dieser Evaluationsphase als hilfreich erweisen,
werden während der weiteren Entwicklung aktiv eingesetzt. Sie sollen den
Entwicklungsprozess begleiten, etwa beim Verständnis von bestehendem Code,
bei der Umsetzung einzelner Features oder bei wiederkehrenden Aufgaben.

Zum Abschluss des Projekts wird ein Fazit zum AI-First-Ansatz gezogen. Dabei
wird festgehalten, welche Tools sich gut bewährt haben, wo deren Stärken und
Grenzen liegen und in welchen Situationen ihr Einsatz sinnvoll ist. Ziel
ist es, diese Erkenntnisse weiterzugeben und anderen Entwicklerinnen und
Entwicklern aufzuzeigen, wo sich der Einsatz von AI im aktuellen Stand der
Technik lohnt.

\section{Abgrenzung}

Dieses Projekt fokussiert sich ausschliesslich auf die technische Umsetzung
der Android-Applikation auf Basis der bestehenden iOS-App. Die iOS-Version
dient dabei als funktionale Referenz und wird mit Jetpack Compose auf Android
nachgebaut und modernisiert.

Es wurden keine Nutzungstests oder Befragungen mit Studierenden
durchgeführt. Ebenso war eine Anpassung des bestehenden
Backends nicht Teil des Projekts.