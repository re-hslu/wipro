\subsection{CommonUtil}

Das Common Util Module stellt eine Sammlung von wiederverwendbaren Utility-Funktionen bereit, 
die von allen Feature-Modulen verwendet werden können. Es bietet Funktionalitäten für Datumsformatierung, 
HTML-Content-Parsing und JSON-Datenlade-Operationen. Diese Utilities zentralisieren häufig verwendete Operationen und vermeiden Code-Duplikation über die gesamte Anwendung hinweg.

\subsubsection*{Ziel und Motivation}

Das Hauptziel besteht darin, häufig verwendete Utility-Funktionen zu zentralisieren und eine konsistente Implementierung über alle Feature-Module hinweg zu gewährleisten. 
Durch die Bereitstellung von wiederverwendbaren Funktionen für Datumsformatierung, HTML-Parsing und JSON-Datenlade-Operationen wird sichergestellt, 
dass alle Module die gleichen Formatierungs- und Parsing-Regeln verwenden.

Ein weiteres wichtiges Ziel ist die Abstraktion komplexer Operationen wie HTML-Parsing und Content-Block-Extraktion, 
die in mehreren Features (News, Blog, Events) benötigt werden. Durch die zentrale Implementierung können Fehlerbehebungen und Verbesserungen an einer Stelle vorgenommen werden, 
die dann allen Modulen zugute kommen.

\subsubsection*{Umsetzung / Funktionsweise}

Das Modul besteht aus drei Hauptkomponenten: \texttt{DateFormatter} für Datumsformatierung, \texttt{HtmlContentParser} für HTML-Parsing und 
\texttt{JsonDataLoader} für JSON-Datenlade-Operationen.

Die \texttt{DateFormatter} Klasse bietet Funktionen zur Formatierung von ISO-Datumsstrings in deutsches Format. 
Die \texttt{formatDate()}-Methode konvertiert ein ISO-formatierte Datum (yyyy-MM-dd'T'HH:mm:ss) in deutsches Format (dd.MM.yyyy):

\begin{lstlisting}[language=Java]
object DateFormatter {
    fun formatDate(isoDate: String): String {
        val inputFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US)
        val outputFormat = SimpleDateFormat("dd.MM.yyyy", Locale("de", "CH"))
        return outputFormat.format(inputFormat.parse(isoDate) ?: Date())
    }
}
\end{lstlisting}

Die \texttt{HtmlContentParser} bietet Funktionen zum Parsen von HTML-Content und Extraktion von Content-Blöcken. 
Die \texttt{stripOutHtml()}-Extension-Funktion entfernt HTML-Tags und dekodiert HTML-Entities:

\begin{lstlisting}[language=Java]
fun String.stripOutHtml(): String {
    return this.replace(Regex("<[^>]*>"), "")
        .replace("&nbsp;", " ")
        .replace("&ldquo;", "\"")
        // ...
}
\end{lstlisting}

Die \texttt{parseContentBlocks()}-Funktion extrahiert strukturierte Content-Blöcke aus HTML und erzeugt eine Liste von \texttt{ContentBlock}-Objekten (z.\,B. \texttt{Paragraph}, \texttt{Subheading}, \texttt{Blockquote}).

Die \texttt{JsonDataLoader} Klasse bietet generische Funktionen für JSON-Datenlade-Operationen. 
Die \texttt{syncData()}-Funktion lädt Daten von Remote oder aus dem lokalen Cache und implementiert eine Offline-First-Strategie.

Die \texttt{reset()}-Funktion ermöglicht das Zurücksetzen und Neu-Synchronisieren von Daten, indem der lokale Cache gelöscht und die Daten erneut vom Remote-Server geladen werden.

\subsubsection*{Weitere Informationen}

\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Aspekt} & \textbf{Beschreibung} \\
\hline
\textbf{DateFormatter} & 
Die \texttt{DateFormatter} verwendet die Zeitzone "Europe/Zurich" und das Locale "de-CH" für schweizerdeutsche Formatierung. 
Dies stellt sicher, dass alle Datumsformatierungen in der Anwendung konsistent sind und der schweizerischen Konvention entsprechen. \\
\hline
\textbf{Offline-First Strategie} & 
Die \texttt{JsonDataLoader} implementiert eine Offline-First-Strategie, bei der zuerst versucht wird, Daten aus dem Netzwerk zu laden, und bei fehlender Verbindung auf den lokalen Cache zurückgegriffen wird. 
Alle Operationen werden asynchron über Kotlin Coroutines auf \texttt{Dispatchers.IO} ausgeführt, um den Main-Thread nicht zu blockieren. \\
\hline
\textbf{Generische Funktionen} & 
Die Verwendung von generischen Funktionen in \texttt{JsonDataLoader} ermöglicht es, die Funktionen mit verschiedenen Datentypen zu verwenden, während die Parsing-Logik von den aufrufenden Modulen bereitgestellt wird. 
Dies gewährleistet Flexibilität bei gleichzeitiger Wiederverwendbarkeit. \\
\hline
\textbf{Abhängigkeiten} & 
Das Modul hat minimale Abhängigkeiten: nur Android Core, Common Domain und Common Infrastructure. 
Dies stellt sicher, dass die Utilities leichtgewichtig bleiben und keine unnötigen Abhängigkeiten einführen. \\
\hline
\end{tabularx}
\caption{Technische Aspekte des \texttt{CommonUtil} Moduls}
\label{tab:commonutil-specs}
\end{table}
