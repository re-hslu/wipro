\subsection{AppInit}

Das Feature \textit{AppInit} bildet die Grundlage für das dynamische Laden und Initialisieren der App-Module zur Laufzeit (Bootstrapping) . 
Die Idee ist analog zur iOS-Implementierung: Menüeinträge werden nicht statisch im Code definiert, 
sondern dynamisch über das Netzwerk geladen, lokal gespeichert und bei Bedarf aktualisiert. 
So kann beispielsweise ein Menüpunkt remote aktiviert oder deaktiviert werden, 
ohne dass eine neue App-Version verteilt werden muss.

\subsubsection*{Ziel und Motivation}
Bereits im Vorgängerprojekt (\textit{Android-XML}) existierte ein ähnlicher Mechanismus.
In der neuen Version sollte die Funktionsweise aber an die Architektur der iOS-App angepasst und somit überarbeitet werden.
Zusätzlich soll die App auch offline funktionieren, indem lokale Daten als Fallback dienen. 
Ein weiteres Ziel ist die Versionsprüfung, um veraltete App-Versionen zu erkennen und den Nutzer zum Update zu leiten.

\subsubsection*{Umsetzung / Funktionsweise}
Beim Start der App wird zunächst das AppInit-Feature geladen, das abhängig von der Konfiguration eine Bootstrapping-Ansicht anzeigt.
In der aktuellen Implementierung erfolgt dies über einen einfachen Splashscreen, der den Initialisierungsprozess visuell begleitet.
Ein Austauschen dieses Screens wäre aber theoretisch über die Config jederzeit möglich.

Das (\textit{AppBootstrappingViewModel}) übernimmt dann im Hintergrund (während der Ladebildschirm angezeigt wird) den Ablauf des Bootstrappings. 
Das Bootstrapping besteht aus zwei zentralen Schritten: der Versionsprüfung sowie dem Laden der Features (Menüpunkte).

\subsubsection*{Versionsprüfung}

Während des Semesters wurde auch die iOS-App weiterentwickelt. 
Ein neues Feature, das beide Plattformen betrifft, ist die versionierte API des Backends, 
um bei Bedarf mehrere Versionen von Daten parallel anbieten zu können.
Aus diesem Grund war es erforderlich, dieses Feature auch in der Android-App umzusetzen,
da beide Applikationen auf dasselbe Backend zugreifen.

Der Versionscheck ist im Feature \textit{AppInit} integriert und stellt sicher,
dass die verwendete App-Version mit dem Backend kompatibel ist.
Der Ablauf des Versionschecks ist wie folgt:


\begin{enumerate}
    \item \textbf{Netzwerkprüfung:} 
    Zuerst wird geprüft, ob eine Netzwerkverbindung besteht. Ohne Verbindung kann die Version nicht zuverlässig bestimmt werden, 
    daher wird \texttt{Unable\_Determine\_Version} zurückgegeben und der Prozess fortgesetzt (tolerant).

    \item \textbf{Lokale Version extrahieren:} 
    Die lokale API-Version wird aus der \textit{AppBootstrappingConfig} gelesen.

    \item \textbf{Remote-Version abrufen:} 
    Die App ruft die Backend-Version über \textit{moduleLoaderVersionUrl} ab. 
    Die Antwort ist ein JSON-Objekt mit einem Feld \texttt{Item}, das die Versionsnummer enthält (z.\,B. \texttt{"V1"}). 
    Fehlt die Antwort oder das Feld, wird ebenfalls \texttt{Unable\_Determine\_Version} zurückgegeben.

    \item \textbf{Versionsvergleich:}
\end{enumerate}

\[
\text{VersionStatus} =
\begin{cases}
\texttt{Please\_Upgrade}, & \text{wenn } \textit{lokaleVersion} < \textit{remoteVersion} \\
\texttt{Dont\_Upgrade},   & \text{wenn } \textit{lokaleVersion} \ge \textit{remoteVersion}
\end{cases}
\]

\newpage

Das Ergebnis ist ein Versionscheck, der erkennt, wenn die lokale App-Version veraltet ist und ein Update erforderlich wird.
Gleichzeitig ist das Feature \textit{tolerant} ausgelegt und versucht, die App dennoch zu laden,
falls die Versionsnummer nicht ermittelt werden kann (z.\,B. bei nicht erreichbarer API).
Dadurch wird das System robuster und weniger fehleranfällig gegenüber temporären Backend- oder Netzwerkproblemen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.175\textwidth]{Fotos/Screenshots/Appversion.png}
    \caption{Aufforderung zum Versionsupdate}
    \label{fig:Appversion}
\end{figure}

\subsubsection*{Laden der Features}

Nach erfolgreicher Versionsprüfung erfolgt im zweiten Schritt das Laden der verfügbaren Features (In diesem Fall die verfügbaren Menüpunkte in der App). 
Dabei werden die Moduldefinitionen über das Backend geladen und mit den lokal gespeicherten Daten synchronisiert.

Dabei wird zuerst geprüft, ob bereits Modul- und Synchronisationsdaten im lokalen Speicher vorhanden sind.
Anhand eines Zeitstempels wird entschieden, ob die lokal gespeicherten Daten (Modulliste) noch aktuell sind oder ob ein Update vom Backend erforderlich ist.
Liegt eine neuere Version der Modulliste vor, werden die Daten aus dem Netzwerk geladen (und dann lokal wieder persistiert).
Falls keine Netzwerkverbindung besteht oder der Abruf fehlschlägt, werden die zuletzt gespeicherten Module als Fallback verwendet.
Dadurch bleibt die App auch im Offline-Betrieb funktionsfähig.

\[
\text{SyncStatus} =
\begin{cases}
\texttt{Load\_Remote}, & \text{wenn } \textit{lokalerZeitstempel} \neq \textit{remoteZeitstempel} \\
\texttt{Use\_Local},   & \text{wenn } \textit{lokalerZeitstempel} = \textit{remoteZeitstempel}
\end{cases}
\]

Nach dem Laden werden die Module entsprechend der gespeicherten Reihenfolge sortiert.

Grundsätzlich wäre es möglich, diese Reihenfolge noch dynamisch (also nach Nutzer-Präferenz) anzupassen. 
Mit dem aktuellen Menükonzept, das auf vier vordefinierten Tab-Gruppen basiert, ergibt dies jedoch wenig Mehrwert 
und wurde daher bewusst nicht freigeschaltet. 
Änderungen im Backend oder das Hinzufügen neuer Module können dennoch dazu führen, 
dass sich die Modulreihenfolge automatisch anpasst.

Abschliessend werden ausschliesslich aktivierte Module berücksichtigt und an die Navigationskomponenten übergeben.
Diese bauen daraus zur Laufzeit die sichtbare App-Navigation auf. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.62\textwidth]{Fotos/flowcharts/appinit.png}
    \caption{Flussdiagramm Menü-Synchronisation}
    \label{fig:appinit}
\end{figure}