\subsubsection{CommonStorage}  \label{sec:commonstorage}

Das Common Storage Modul stellt die zentrale Speicherschicht der Anwendung dar und bietet eine einheitliche Schnittstelle für persistente Datenspeicherung. 
Es verwendet Android's Room-Datenbank als Backend und abstrahiert alle Datenbankoperationen hinter einem einfachen Service-Interface. 
Der \texttt{CommonStorageService} ermöglicht es, verschiedene Arten von Daten zu speichern: AppInitModule-Konfigurationen, Modul-JSON-Daten,  
Synchronisations-Timestamps und Dateien.

\subsubsection*{Ziel und Motivation}

Das Hauptziel besteht darin, eine zentrale, wiederverwendbare Speicherlösung zu schaffen, die von allen Feature-Modulen verwendet werden kann, 
ohne dass jedes Modul seine eigene Datenbank-Implementierung benötigt. Durch die Verwendung von Room als Backend wird eine robuste, 
typsichere und performante Datenbankzugriffsschicht bereitgestellt, die automatisch SQL-Abfragen generiert und Compile-Zeit-Validierung bietet.

Ein weiteres wichtiges Ziel ist die Abstraktion der Datenbankkomplexität. Anstatt dass jedes Modul direkt mit Room-Entities und DAOs arbeitet, 
bietet der \texttt{CommonStorageService} eine einfache, suspend-Funktion-basierte API, die DTOs aus der Domänenschicht verwendet. 
Dies ermöglicht es, die Datenbank-Implementierung zu ändern, ohne dass die Anwendungsschicht betroffen ist.

Die Verwendung von Kotlin Coroutines für alle Datenbankoperationen stellt sicher, dass Blockierungen des Main-Threads vermieden werden und die Anwendung reaktionsfähig bleibt. 
Alle Operationen werden automatisch auf \texttt{Dispatchers.IO} ausgeführt, was eine optimale Performance gewährleistet.

\subsubsection*{Umsetzung / Funktionsweise}

Die Implementierung basiert auf Android's Room-Persistenzbibliothek. Die \texttt{AppDatabase} ist die zentrale Datenbankklasse, 
die alle Entities und DAOs verwaltet:

\begin{lstlisting}[language=Java]
@Database(
    entities = [ModuleDataEntity::class, FileEntity::class, ...],
    version = 1
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun moduleDataDao(): ModuleDataDao
    // ...
}
\end{lstlisting}

Der \texttt{CommonStorageService} verwendet das Singleton-Pattern für die Datenbankinstanz und bietet eine Factory-Methode zur Erstellung.

Für die Speicherung von Modul-Daten wird die \texttt{ModuleDataEntity} verwendet, die JSON-Daten als String speichert:

\begin{lstlisting}[language=Java]
@Entity(tableName = "module_data")
data class ModuleDataEntity(
    @PrimaryKey val moduleId: String,
    val jsonData: String,
    val lastUpdated: String
)
\end{lstlisting}

Die \texttt{storeModuleData()}-Methode konvertiert DTOs in Entities und speichert sie in der Datenbank.

Die \texttt{getModuleData()}-Methode lädt Daten aus der Datenbank und gibt sie als JSON-String zurück.

Für AppInitModule-Daten werden DTOs in Entities konvertiert. Die \texttt{storeAppInitModules()}-Methode mappt eine Liste von DTOs zu Entities.

Die \texttt{getAppInitModuleOrder()}-Methode demonstriert eine komplexere Abfrage, 
die Daten aus mehreren Tabellen kombiniert.

Für Dateispeicherung wird die \texttt{FileEntity} verwendet, die Dateien als \texttt{ByteArray} speichert:

\begin{lstlisting}[language=Java]
@Entity(tableName = "files")
data class FileEntity(
    @PrimaryKey val fileId: String,
    val data: ByteArray,
    val mimeType: String
)
\end{lstlisting}

\subsubsection*{Weitere Informationen}

\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Aspekt} & \textbf{Beschreibung} \\
\hline
\textbf{Asynchrone Operationen} & Alle Datenbankoperationen werden asynchron über Kotlin Coroutines ausgeführt. Die Verwendung von \texttt{withContext(Dispatchers.IO)} stellt sicher, dass alle Operationen auf dem IO-Dispatcher laufen und den Main-Thread nicht blockieren. Dies ist besonders wichtig für grössere Datenmengen oder komplexe Abfragen. \\
\hline
\textbf{Fehlerbehandlung} & 
Die Fehlerbehandlung erfolgt durch try-catch-Blöcke, die Fehler loggen und \texttt{null} oder \texttt{false} zurückgeben, anstatt Exceptions zu werfen. Dies ermöglicht es den aufrufenden Komponenten, elegant mit Fehlern umzugehen, ohne dass die gesamte Anwendung abstürzt. \\
\hline
\textbf{Singleton-Pattern} & 
Die Datenbank verwendet das Singleton-Pattern mit thread-sicherer Initialisierung. Die \texttt{getDatabase()}-Methode verwendet \texttt{synchronized}, um sicherzustellen, dass nur eine Instanz der Datenbank erstellt wird, auch bei gleichzeitigen Zugriffen von mehreren Threads. \\
\hline
\textbf{Datenbank-Migrationen} & Die Verwendung von \texttt{fallbackToDestructiveMigration(true)} bedeutet, dass bei Schema-Änderungen die Datenbank neu erstellt wird. Dies ist für Entwicklung geeignet, sollte aber in Produktion durch Migrationen ersetzt werden. \\
\hline
\textbf{DAOs} & Die DAOs verwenden Room-Annotationen für typsichere SQL-Abfragen. Beispielsweise verwendet \texttt{ModuleDataDao} \texttt{@Query}-Annotationen für benutzerdefinierte Abfragen. Die DAO-Interfaces werden mit \texttt{@Dao} annotiert und enthalten suspend-Funktionen für asynchrone Datenbankzugriffe. \\
\hline
\textbf{OnConflictStrategy} & Die Verwendung von \texttt{OnConflictStrategy.REPLACE} bei Insert-Operationen stellt sicher, dass vorhandene Einträge aktualisiert werden, anstatt Fehler zu verursachen. Dies ist besonders nützlich für Synchronisationsoperationen, bei denen Daten regelmässig aktualisiert werden. \\
\hline
\textbf{Dateispeicherung} & Der Service unterstützt auch Dateispeicherung, was für Features wie CampusRoomSearch wichtig ist, die PDF-Dateien speichern müssen. Die \texttt{storeFile()}- und \texttt{getFile()}-Methoden ermöglichen es, beliebige Binärdaten zu speichern und abzurufen, ohne dass externe Dateisystem-Zugriffe erforderlich sind. \\
\hline
\end{tabularx}
\caption{Technische Aspekte des \texttt{CommonStorage} Moduls}
\label{tab:commonstorage-specs}
\end{table}