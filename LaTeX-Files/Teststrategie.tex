\section{Teststrategie – Android Multi-Tenant App (Jetpack Compose)}

Todo Raphi: Überarbeitung

\subsection{Ausgangslage}
In der bisherigen mobilen Applikationslandschaft – sowohl bei der iOS-App als auch bei der älteren Android-App auf XML-Basis – war die Testabdeckung sehr gering.  
Es existierten nur wenige automatisierte Tests, meist oberflächliche oder technische Tests ohne echten Bezug zur Geschäftslogik. Dadurch war die Qualitätssicherung stark manuell geprägt, und Änderungen am Code konnten nur mit hohem Aufwand überprüft werden.

Mit der Neuentwicklung der Android-App auf Basis von Jetpack Compose soll dieser Zustand deutlich verbessert werden. Ziel ist es, eine strukturierte, modulare und wartbare Teststrategie aufzubauen, die langfristig eine hohe Codequalität und Stabilität sicherstellt.

\subsection{Zielsetzung}
\begin{itemize}
    \item Aufbau einer einheitlichen Testarchitektur über alle Module hinweg
    \item Erhöhung der Testabdeckung, insbesondere in der Business Logic und bei den ViewModels
    \item Klare Trennung zwischen Unit-, Integrations- und UI-Tests
    \item Einführung moderner Testframeworks mit JUnit 5 (Jupiter)
\end{itemize}

\subsection{Umsetzung}

\subsubsection{Testarten und Vorgehen}

\paragraph{Unit Tests (\texttt{src/test/})}
Ziel: Isolierte Tests einzelner Klassen und Methoden ohne Android-Abhängigkeiten

Frameworks: JUnit 5, Mockito oder MockK

Fokus: Business Logic, Datenmodelle und ViewModels

Vorgehen:
\begin{itemize}
    \item Jede logische Komponente (z.\,B. Parser, Berechnungen, ViewModels) erhält eigene Unit Tests
    \item Abhängigkeiten werden gemockt, um reine Logiktests zu ermöglichen
    \item Tests folgen dem AAA-Prinzip (Arrange – Act – Assert) und klaren Namenskonventionen
\end{itemize}

\noindent Beispiel:
\begin{lstlisting}
@Test
fun `should return correct sum when valid input provided`() {
    val calculator = Calculator()
    val a = 5
    val b = 3
    val result = calculator.add(a, b)
    assertEquals(8, result)
}
\end{lstlisting}

\paragraph{Integration- und UI-Tests (\texttt{src/androidTest/})}
Ziel: Überprüfung des Zusammenspiels mehrerer Komponenten im echten Android-Kontext

Frameworks: JUnit 5, Espresso, Jetpack Compose Testing

Fokus: UI-Verhalten, Datenfluss, Netzwerk- und Datenbankinteraktionen

Vorgehen:
\begin{itemize}
    \item Tests laufen mit Android Emulator oder Gerät
    \item Überprüfen reale Benutzerinteraktionen (z.\,B. Klicks, Eingaben, Navigationsflüsse)
    \item Fokus auf Haupt-Userflows und kritische Systempfade
\end{itemize}

\subsection{Struktur und Modularität}
Jedes Modul (z.\,B. App, Common, Features) verfügt über eigene Testverzeichnisse:
\begin{itemize}
    \item \texttt{src/test/} → Unit Tests  
    \item \texttt{src/androidTest/} → Instrumentierte Integration- und UI-Tests  
\end{itemize}

Diese klare Trennung ermöglicht modulunabhängiges Testen, parallele Ausführung und einfache Erweiterung der Testbasis.

\subsection{Zielwerte und Qualität}
\begin{itemize}
    \item Unit-Test-Abdeckung: mindestens 80\,\%
    \item Integration/UI-Tests: Fokus auf kritische Anwendungsfälle
    \item CI/CD-Integration: Automatische Testausführung bei jedem Build
    \item Langfristig: Schrittweise Ausweitung auf alle bestehenden Module
\end{itemize}

\subsection{Fazit}
Mit der neuen Jetpack-Compose-Architektur wurde eine klare und moderne Teststruktur geschaffen, die auf JUnit 5 basiert und sowohl Unit- als auch Android-Tests konsequent trennt.  
Damit wird erstmals eine nachhaltige Testbasis gelegt, um Qualität, Stabilität und Wartbarkeit der App langfristig sicherzustellen.
