\subsection{BuildConfig im Projekt}
Im Android-Projekt wurde die \texttt{BuildConfig}-Struktur zentralisiert und tenant-spezifisch erweitert. Ziel war es, alle wichtigen Konfigurationswerte und Feature-Flags pro Tenant konsistent an einer Stelle zu definieren, um Redundanzen und Hardcodings zu vermeiden. 

\subsubsection{Idee und Motivation}
In der vorherigen Umsetzung waren Konfigurationen über verschiedene Klassen verteilt, beispielsweise in \texttt{HsluIApplication} oder einzelnen Modulen. Dies erschwerte die Wartung und Übersicht.  
Neu werden sämtliche Tenant-spezifischen Werte zentral im \texttt{app/build.gradle} verwaltet. Dort sind alle \texttt{BuildConfig}-Felder je Flavor (\texttt{hslui} und \texttt{hsluta}) definiert und werden beim Build-Prozess automatisch generiert.

\subsubsection{Implementierung}
Jeder Tenant besitzt im Abschnitt \texttt{productFlavors} eigene Einträge. Dabei werden Variablen wie \texttt{TENANT\_ID}, \texttt{API\_BASE\_URL} oder \texttt{CLIENT\_TOKEN} über \texttt{buildConfigField} gesetzt.  
Zur Laufzeit greift der Code direkt über \texttt{BuildConfig.FELDNAME} auf diese Werte zu. Somit wird je nach aktivem Flavor (z. B. \texttt{hsluiDebug} oder \texttt{hslutaRelease}) automatisch die passende Konfiguration geladen.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Tenant} & \textbf{Base URL} & \textbf{Client Token} \\ \hline
        HSLU I & \texttt{https://hslui.mobile-hslu.ch} & \texttt{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} \\ \hline
        HSLU TA & \texttt{https://hsluta.mobile-hslu.ch} & \texttt{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} \\ \hline
    \end{tabular}
    \caption{Tenant-spezifische BuildConfig-Werte}
    \label{tab:buildconfig_tenants}
\end{table}

\subsubsection{Beispiel aus \texttt{build.gradle}}
\begin{lstlisting}
productFlavors {
    create("hslui") {
        dimension = "tenant"
        applicationIdSuffix = ".hslui"
        versionNameSuffix = "-HSLUI"
        buildConfigField("String", "TENANT_ID", "\"hslui\"")
        buildConfigField("String", "TENANT_NAME", "\"HSLU I\"")
        buildConfigField("String", "API_BASE_URL", "\"https://hslui.mobile-hslu.ch\"")
        buildConfigField("String", "CLIENT_TOKEN", "\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"")
    }
    create("hsluta") {
        dimension = "tenant"
        applicationIdSuffix = ".hsluta"
        versionNameSuffix = "-HSLUTA"
        buildConfigField("String", "TENANT_ID", "\"hsluta\"")
        buildConfigField("String", "TENANT_NAME", "\"HSLU TA\"")
        buildConfigField("String", "API_BASE_URL", "\"https://hsluta.mobile-hslu.ch\"")
        buildConfigField("String", "CLIENT_TOKEN", "\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"")
    }
}
\end{lstlisting}

\subsubsection{Verwendung im Code}
In der \texttt{MainActivity} oder anderen Klassen wird direkt auf die generierten Felder zugegriffen, z.~B.:
\begin{lstlisting}
val tenantId = BuildConfig.TENANT_ID
val tenantName = BuildConfig.TENANT_NAME
val tenantDisplayName = BuildConfig.TENANT_DISPLAY_NAME
val tenantLogoName = BuildConfig.TENANT_LOGO_NAME
\end{lstlisting}

\subsubsection{Vorteile}
\begin{itemize}
    \item Klare Trennung zwischen den Tenants (\texttt{hslui}, \texttt{hsluta})
    \item Kein Hardcoding von URLs oder Tokens im Code
    \item Automatische Tenant-Auswahl über Build Variants
    \item Einheitliche Nutzung von Feature-Flags für Module (z.~B. \texttt{ENABLE\_PARKING}, \texttt{ENABLE\_TRAIL})
\end{itemize}

\subsubsection{Dateistruktur}
\dirtree{%
.1 app/.
.2 build.gradle.
.2 src/.
.3 hslui/.
.4 java/ch/hslu/i/config/.
.4 java/ch/hslu/i/di/.
.3 hsluta/.
.4 java/ch/hslu/ta/config/.
.4 java/ch/hslu/ta/di/.
.3 main/java/ch/hslu/mobileapps/ui/.
.4 MainActivity.kt.
}

\subsubsection{Zusammenfassung}
Durch die zentrale Definition aller Tenant-Konfigurationen im \texttt{build.gradle} konnte die bisher verstreute Logik vereinheitlicht werden.  
Die App verwendet beim Build automatisch die jeweils korrekten Werte und Feature-Flags, ohne dass diese im Code hart verdrahtet sind.  
Dies erhöht die Wartbarkeit, reduziert Fehlerquellen und ermöglicht eine klare Trennung der Umgebungen für HSLU~I und HSLU~TA.